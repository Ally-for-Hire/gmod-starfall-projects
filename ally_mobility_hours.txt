--@name Ally Mobility Hours
--@author Ally for Hire / Merydian9
--@server

--- Version 0.10.1
-- Sourced from https://github.com/Ally-for-Hire/gmod-starfall-projects/blob/main/ally_mobility_hours.txt
-- GITHUB: https://github.com/Ally-for-Hire/gmod-starfall-projects/tree/main
-- GOOGLE DRIVE: https://drive.google.com/drive/folders/1arb3QgrZkKfF06vdEVqD4samK23IfJrT?dmr=1&ec=wgc-drive-globalnav-goto

/*
--- Overview
Plug-and-play mobility brain for tracked or wheeled ACF vehicles. It manages autogearing, clutch modulation, braking, and counter-steer logic so you can concentrate on driving instead of spinning out.

--- Wiring
-- Inputs
1. "MainGearbox" -> main gearbox (typically the largest gearbox on the vehicle).
2. "Engine" -> the engine you want monitored; pick the one with the largest powerband if you have multiple different types.
3. "Base" -> vehicle baseplate entity.
4. "Pod" -> pod controller
-- Outputs
1. "Throttle" <- all of your engines' throttle inputs.

Once those links are set, the chip begins driving the gearbox and throttle outputs automatically.

--- Customizing
Every tunable sits in the "Customizable Variables" block and includes inline descriptions.

Key notes:
- "gearingType": "1" uses RPM-based shifts, "2" uses speed gates, and "3" blends both. Hybrid is the recommended default.
- "wheelSize" and "finalRatio" should match your physical wheel diameter and combined gearbox ratios so the shift map stays accurate. Example: (1/1.5) * (1/1.4).
- Flip "showDebug" on to review gear-speed targets; nudge "wheelSize" if the speeds feel off.
- Counter-steer defaults are tuned for general use. Only tweak them for exceptionally unusual drivetrains.
- "clutchStart" comes from Cheezus' clutch curve; leave it at "0.8" unless you have a specific low-RPM behaviour to chase.

Need a hand tailoring it to a particular rig? Ping @allyfh and I'll walk you through it.
*/

--- Constants
local SPEEDCONV = 1/17.6

--- Customizable Variables
-- Gearing and Braking Setup
local gearingType         = 1
local maxBrakePower       = 100
local brakeScaling        = false
local wheelSize           = 30
local finalRatio          = (1/1.8)*(0.75)
local idleThrottle        = 20
local disableNeutralSteer = true

-- Vehicle Setup 
local hasWheels = false
local dualClutch = true
local invertedTransfers = 1
local inlineTransfers = true

-- Countersteering Setup
local yawDeadzone = 25
local counterSteerStrength = 1.25

-- Misc
local showDebug = false
local clutchStart = 0.8
local fancyClutchBullshit = true

--- Internal Variables
local clutchTurn = 1
local clutchBrake = 1
local minClutch = 0
local remainderClutch = 0
local gearCount = 0
local gearUpBuffer = 1.05
local gearDownBuffer = 0.95
local biteRPM, releaseRPM = 0, 0
local powerMin, powerMax = 0, 0
local upshiftRPM, downshiftRPM = 0, 0

local input_engine = nil
local input_mainGearbox = nil
local input_base = nil
local input_pod = nil

local gears = {}
local gearLinks = {}
local gearSpeeds = {}
local reverseGears = 0
local isAutogearing = false
local canNeutralSteer = false
local acf3GearRatios = true
local maxCountersteerBrake = 1

local output_gear = 1
local output_throttle = 0
local outputRightGear = 1
local outputLeftGear = 1
local outputRightClutch = clutchBrake
local outputLeftClutch = clutchBrake
local outputRightBrake = maxBrakePower
local outputLeftBrake = maxBrakePower
local leftTransfer = nil
local rightTransfer = nil

local lastGear, lastThrottle = nil, nil
local lastLBrake, lastRBrake = nil, nil
local lastLClutch, lastRClutch = nil, nil
local lastLGear, lastRGear = nil, nil
local lastLWeld, lastRWeld = nil, nil

--- Functions
local function applyBrakeClutch(LBrake, RBrake, LClutch, RClutch)
    outputRightClutch = RClutch
    outputLeftClutch = LClutch
    outputRightBrake = RBrake
    outputLeftBrake = LBrake
end

local function updateEngineVariables()
    powerMin = input_engine:acfPowerbandMin()
    powerMax = input_engine:acfPowerbandMax()

    biteRPM = powerMin * clutchStart
    releaseRPM = powerMin
    minClutch = 1 - (input_engine:acfMaxTorque() / input_mainGearbox:acfTorqueRating())
    remainderClutch = 1 - minClutch

    upshiftRPM = powerMax * 0.95
    downshiftRPM = powerMin * 0.85

    gearCount = input_mainGearbox:acfNumGears()
    reverseGears = 0
    for i = 1, gearCount do
        local ratio = input_mainGearbox:acfGearRatio(i)
        gears[i] = ratio
        if ratio < 0 then
            reverseGears = reverseGears + 1
        end
    end
    gearCount = gearCount - reverseGears
    isAutogearing = gearCount > 2

    acf3GearRatios = math.abs(input_mainGearbox:acfGearRatio(1)) > 1
    local commonVal = (powerMax * finalRatio / 60) * wheelSize * math.pi

    if isAutogearing then
        if showDebug then print("Gear Speeds:") end
        if acf3GearRatios then
            for i = 1, gearCount + reverseGears do
                gearSpeeds[i] = math.abs(commonVal * (1 / input_mainGearbox:acfGearRatio(i)) * SPEEDCONV)
                if showDebug then print("    " .. i .. " .. " .. gearSpeeds[i]) end
            end
        else
            for i = 1, gearCount + reverseGears do
                gearSpeeds[i] = math.abs(commonVal * (input_mainGearbox:acfGearRatio(i)) * SPEEDCONV)
                if showDebug then print("    " .. i .. " .. " .. gearSpeeds[i]) end
            end
        end
    end

    gearLinks = input_mainGearbox:acfLinks()

    local transfers = 0
    for i = 1, #gearLinks do
        if gearLinks[i]:getClass() == "prop_physics" then continue end
        local type = gearLinks[i]:acfType()
        if type == "Transfer Case" or type == "Transfer" then
            transfers = transfers + 1
            local y = input_mainGearbox:worldToLocal(gearLinks[i]:getPos()).y
            if y * invertedTransfers < 0 then rightTransfer = gearLinks[i] end
            if y * invertedTransfers > 0 then leftTransfer = gearLinks[i] end
        end
    end

    if transfers >= 2 then canNeutralSteer = true end

    if showDebug then
        if acf3GearRatios and isAutogearing then print("This Vehicle Uses ACF3 Gears") elseif isAutogearing then print("This vehicle Uses ACE Gears") end
        print("Detected Forward Gears .. " .. gearCount)
        print("Detected Reverse Gears .. " .. reverseGears)
        print("Detected Transfers .. " .. transfers)
        if isAutogearing then print("Autogearing Enabled") else print("Autogearing Disabled") end
        if canNeutralSteer then print("The Vehicle Can Neutral Steer") else print("The Vehicle Cannot Neutral Steer") end
    end
end

local function handleWire(name, value)
    if value == nil then return end
    if name == "Engine" then
        input_engine = value
    elseif name == "MainGearbox" then
        input_mainGearbox = value
    elseif name == "Base" then
        input_base = value
    elseif name == "Pod" then
        input_pod = value
    end
end

local function think()
    if not input_engine or not input_mainGearbox or not input_base or not input_pod then return end
    if biteRPM == 0 then updateEngineVariables() end

    local vel = input_base:getVelocity()
    local speed = vel:getLength() * SPEEDCONV
    local rpm = input_engine:acfRPM()
    local W = input_pod["W"]
    local A = input_pod["A"]
    local S = input_pod["S"]
    local D = input_pod["D"]
    local hasInput = (W == 1 or A == 1 or S == 1 or D == 1)

    outputLeftGear = 1
    outputRightGear = 1

    if not hasInput and speed < 1 and rpm < biteRPM then
        if output_throttle ~= idleThrottle then
            output_throttle = idleThrottle
        end

        local gbxWL = input_mainGearbox:getWirelink()

        if lastGear ~= output_gear then
            gbxWL["Gear"] = output_gear
            lastGear = output_gear
        end

        if lastThrottle ~= output_throttle then
            wire.ports.Throttle = output_throttle
            lastThrottle = output_throttle
        end

        local lweld = outputLeftBrake > 0 and 1 or 0
        local rweld = outputRightBrake > 0 and 1 or 0

        if lastLWeld ~= lweld then
            wire.ports.LeftWeldLatch = lweld
            lastLWeld = lweld
        end
        if lastRWeld ~= rweld then
            wire.ports.RightWeldLatch = rweld
            lastRWeld = rweld
        end

        return
    end

    local brakePower = maxBrakePower
    if brakeScaling then
        if isAutogearing and gearSpeeds[gearCount] and speed > 1 then
            brakePower = maxBrakePower * math.min(gearSpeeds[gearCount] / 2 / speed, 1)
        elseif speed > 1 then
            brakePower = maxBrakePower * math.min(30 / speed, 1)
        end
    end

    applyBrakeClutch(brakePower, brakePower, clutchBrake, clutchBrake)

    if hasInput then
        output_throttle = 100
        local clutchRelease = 1 - math.clamp((rpm - biteRPM) / (releaseRPM - biteRPM), 0, 1)
        applyBrakeClutch(0, 0, clutchRelease, clutchRelease)
    else
        output_throttle = idleThrottle
    end

    if isAutogearing then
        local usableGears = gearCount
        local min_gear = 1

        if S == 1 and not canNeutralSteer then
            usableGears = gearCount + reverseGears
            min_gear = gearCount + 1
            output_gear = gearCount + 1
        end

        if gearingType == 1 then
            if rpm > upshiftRPM and output_gear < usableGears then
                output_gear = output_gear + 1
            elseif rpm < downshiftRPM and output_gear > min_gear then
                output_gear = output_gear - 1
            end

        elseif gearingType == 2 then
            if output_gear < usableGears and speed > gearSpeeds[output_gear] * gearUpBuffer then
                output_gear = output_gear + 1
            elseif output_gear > min_gear and speed < gearSpeeds[output_gear - 1] * gearDownBuffer then
                output_gear = output_gear - 1
            end

        elseif gearingType == 3 then
            if output_gear < usableGears and (speed > gearSpeeds[output_gear] * gearUpBuffer or rpm > upshiftRPM) then
                output_gear = output_gear + 1
            elseif output_gear > min_gear and (speed < gearSpeeds[output_gear - 1] * gearDownBuffer and rpm < powerMin) then
                output_gear = output_gear - 1
            end
        end
    else
        if canNeutralSteer then
            output_gear = 1
        else
            output_gear = 1 + S
        end
    end

    if canNeutralSteer and not hasWheels then
        if W == 0 and S == 0 then
            if A == 1 then
                outputLeftGear = 2
                outputRightGear = 1
            elseif D == 1 then
                outputLeftGear = 1
                outputRightGear = 2
            end
        elseif W == 0 and S == 1 then
            outputLeftGear = 2
            outputRightGear = 2
            if A == 1 then
                applyBrakeClutch(brakePower, 0, clutchTurn, outputRightClutch)
            elseif D == 1 then
                applyBrakeClutch(0, brakePower, outputLeftClutch, clutchTurn)
            end
        elseif W == 1 and S == 0 then
            if A == 1 then
                applyBrakeClutch(brakePower, 0, clutchTurn, outputRightClutch)
            elseif D == 1 then
                applyBrakeClutch(0, brakePower, outputLeftClutch, clutchTurn)
            end
        end
    end

    if not hasWheels and (W == 1 or S == 1) and A == 0 and D == 0 then
        local yawRate = input_base:getAngleVelocity().z
        if math.abs(yawRate) > yawDeadzone then
            local counterSteerWeight = math.min(yawRate / 240 * counterSteerStrength, maxCountersteerBrake) * brakePower
            local direction = (S == 1) and -1 or 1
            if counterSteerWeight * direction < 0 then
                outputLeftBrake = math.abs(counterSteerWeight)
            else
                outputRightBrake = math.abs(counterSteerWeight)
            end
        end
    end

    local gbxWL = input_mainGearbox:getWirelink()

    if lastGear ~= output_gear then
        gbxWL["Gear"] = output_gear
        lastGear = output_gear
    end

    if lastThrottle ~= output_throttle then
        wire.ports.Throttle = output_throttle
        lastThrottle = output_throttle
    end

    local lweld = outputLeftBrake > 0 and 1 or 0
    local rweld = outputRightBrake > 0 and 1 or 0

    if lastLWeld ~= lweld then
        wire.ports.LeftWeldLatch = lweld
        lastLWeld = lweld
    end
    if lastRWeld ~= rweld then
        wire.ports.RightWeldLatch = rweld
        lastRWeld = rweld
    end

    if canNeutralSteer then
        local lWL = leftTransfer:getWirelink()
        local rWL = rightTransfer:getWirelink()

        if lastLBrake ~= outputLeftBrake then
            lWL["Left Brake"] = outputLeftBrake
            lWL["Right Brake"] = outputLeftBrake
            lastLBrake = outputLeftBrake
        end
        if lastRBrake ~= outputRightBrake then
            rWL["Left Brake"] = outputRightBrake
            rWL["Right Brake"] = outputRightBrake
            lastRBrake = outputRightBrake
        end

        if lastLClutch ~= outputLeftClutch then
            lWL["Left Clutch"] = outputLeftClutch
            lWL["Right Clutch"] = outputLeftClutch
            lastLClutch = outputLeftClutch
        end
        if lastRClutch ~= outputRightClutch then
            rWL["Left Clutch"] = outputRightClutch
            rWL["Right Clutch"] = outputRightClutch
            lastRClutch = outputRightClutch
        end

        if inlineTransfers then
            if lastLGear ~= outputLeftGear then
                lWL["Gear"] = outputLeftGear
                lastLGear = outputLeftGear
            end
            if lastRGear ~= outputRightGear then
                rWL["Gear"] = outputRightGear
                lastRGear = outputRightGear
            end
        else
            if lastLGear ~= outputLeftGear then
                lWL["Left Gear"] = outputLeftGear
                lWL["Right Gear"] = outputLeftGear
                lastLGear = outputLeftGear
            end
            if lastRGear ~= outputRightGear then
                rWL["Left Gear"] = outputRightGear
                rWL["Right Gear"] = outputRightGear
                lastRGear = outputRightGear
            end
        end

    elseif dualClutch then
        if lastLBrake ~= outputLeftBrake or lastRBrake ~= outputRightBrake then
            gbxWL["Left Brake"] = outputLeftBrake
            gbxWL["Right Brake"] = outputRightBrake
            lastLBrake = outputLeftBrake
            lastRBrake = outputRightBrake
        end

        if lastLClutch ~= outputLeftClutch or lastRClutch ~= outputRightClutch then
            gbxWL["Left Clutch"] = outputLeftClutch
            gbxWL["Right Clutch"] = outputRightClutch
            lastLClutch = outputLeftClutch
            lastRClutch = outputRightClutch
        end
    else
        if lastLBrake ~= outputLeftBrake then
            gbxWL["Brake"] = outputLeftBrake
            lastLBrake = outputLeftBrake
        end

        if lastLClutch ~= outputLeftClutch then
            gbxWL["Clutch"] = outputLeftClutch
            lastLClutch = outputLeftClutch
        end
    end
end

--- Hooks
wire.adjustPorts(
    {Engine = "entity", MainGearbox = "entity", Base = "entity", Pod = "wirelink"},
    {Throttle = "number", LeftWeldLatch = "number", RightWeldLatch = "number"}
)
hook.add("input", "Wire Inputs Updated", handleWire)
timer.create("Main Logic Loop", 0.05, 0, think)
