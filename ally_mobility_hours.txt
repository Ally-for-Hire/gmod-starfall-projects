--@name Ally Mobility Hours
--@author Ally for Hire / Merydian9
--@server

--- Version 0.11.0
-- Sourced from https://github.com/Ally-for-Hire/gmod-starfall-projects/blob/main/ally_mobility_hours.txt
-- GITHUB: https://github.com/Ally-for-Hire/gmod-starfall-projects/tree/main
-- GOOGLE DRIVE: https://drive.google.com/drive/folders/1arb3QgrZkKfF06vdEVqD4samK23IfJrT?dmr=1&ec=wgc-drive-globalnav-goto

/*
--- Overview
Plug-and-play mobility brain for tracked or wheeled ACF vehicles. It manages autogearing, clutch modulation, braking, and counter-steer logic so you can concentrate on driving instead of spinning out.

--- Wiring
-- Inputs
1. "MainGearbox" -> main gearbox (typically the largest gearbox on the vehicle).
2. "Engine" -> the engine you want monitored; pick the one with the largest powerband if you have multiple different types.
3. "Base" -> vehicle baseplate entity.
4. "Pod" -> pod controller
-- Outputs
1. "Throttle" <- all of your engines' throttle inputs.

Once those links are set, the chip begins driving the gearbox and throttle outputs automatically.

--- Customizing
Every tunable sits in the "Customizable Variables" block and includes inline descriptions.

Key notes:
- "gearingType": "1" uses RPM-based shifts, "2" uses speed gates, and "3" blends both. Hybrid is the recommended default.
- "wheelSize" and "finalRatio" should match your physical wheel diameter and combined gearbox ratios so the shift map stays accurate. Example: (1/1.5) * (1/1.4).
- Flip "showDebug" on to review gear-speed targets; nudge "wheelSize" if the speeds feel off.
- Counter-steer defaults are tuned for general use. Only tweak them for exceptionally unusual drivetrains.
- "clutchStart" comes from Cheezus' clutch curve; leave it at "0.8" unless you have a specific low-RPM behaviour to chase.

Need a hand tailoring it to a particular rig? Ping @allyfh and I'll walk you through it.
*/

--- Constants
local SPEEDCONV = 1 / 17.6
local MAX_YAW_RATE = 240
local BRAKE_SPEED_GATE = 30

--- Customizable Variables
-- Gearing and Braking Setup
local gearingType         = 3
local maxBrakePower       = 150
local brakeScaling        = false
local wheelSize           = 28
local finalRatio          = 0.18
local idleThrottle        = 20
local disableNeutralSteer = false

-- Vehicle Setup 
local hasWheels = false
local dualClutch = false
local invertedTransfers = 1
local inlineTransfers = true

-- Countersteering Setup
local yawDeadzone = 15
local counterSteerStrength = 1.5

-- Steering Setup
local invertSteer = false
local invertReverseSteer = false

-- Misc
local showDebug = false
local clutchStart = 0.8

--- Internal Variables
local clutchTurn = 1
local clutchBrake = 1
local gearCount = 0
local gearUpBuffer = 1.05
local gearDownBuffer = 0.95
local biteRPM, releaseRPM = 0, 0
local powerMin, powerMax = 0, 0
local upshiftRPM, downshiftRPM = 0, 0

local input_engine = nil
local input_mainGearbox = nil
local input_base = nil
local input_pod = nil

local mainWL = nil
local leftWL = nil
local rightWL = nil
local engineReady = false

local gears = {}
local gearLinks = {}
local gearSpeeds = {}
local reverseGears = 0
local isAutogearing = false
local canNeutralSteer = false
local acf3GearRatios = true

local output_gear = 1
local output_throttle = 0
local outputRightGear = 1
local outputLeftGear = 1
local outputRightClutch = clutchBrake
local outputLeftClutch = clutchBrake
local outputRightBrake = maxBrakePower
local outputLeftBrake = maxBrakePower
local leftTransfer = nil
local rightTransfer = nil

local lastGear, lastThrottle = nil, nil
local lastLBrake, lastRBrake = nil, nil
local lastLClutch, lastRClutch = nil, nil
local lastLGear, lastRGear = nil, nil
local lastLWeld, lastRWeld = nil, nil

--- Functions
local function applyBrakeClutch(LBrake, RBrake, LClutch, RClutch)
    outputRightClutch = RClutch
    outputLeftClutch = LClutch
    outputRightBrake = RBrake
    outputLeftBrake = LBrake
end

local function writeWireIfChanged(wl, key, value, lastValue)
    if not wl then return lastValue end
    if lastValue ~= value then
        wl[key] = value
        return value
    end
    return lastValue
end

local function writeWirePairIfChanged(wl, keyA, keyB, value, lastValue)
    if not wl then return lastValue end
    if lastValue ~= value then
        wl[keyA] = value
        wl[keyB] = value
        return value
    end
    return lastValue
end

local function writePortIfChanged(key, value, lastValue)
    if lastValue ~= value then
        wire.ports[key] = value
        return value
    end
    return lastValue
end

local function selectGear(rpm, speed, driveDir, neutralSteerEnabled)
    if not isAutogearing then
        if neutralSteerEnabled then
            return 1
        end
        if driveDir < 0 and reverseGears > 0 then
            return gearCount + 1
        end
        return 1
    end

    local minGear = 1
    local maxGear = gearCount

    if driveDir < 0 and not neutralSteerEnabled and reverseGears > 0 then
        minGear = gearCount + 1
        maxGear = gearCount + reverseGears
    end

    local newGear = output_gear
    if newGear < minGear or newGear > maxGear then
        newGear = minGear
    end

    if gearingType == 1 then
        if rpm > upshiftRPM and newGear < maxGear then
            newGear = newGear + 1
        elseif rpm < downshiftRPM and newGear > minGear then
            newGear = newGear - 1
        end
    elseif gearingType == 2 then
        if newGear < maxGear and speed > gearSpeeds[newGear] * gearUpBuffer then
            newGear = newGear + 1
        elseif newGear > minGear and speed < gearSpeeds[newGear - 1] * gearDownBuffer then
            newGear = newGear - 1
        end
    elseif gearingType == 3 then
        if newGear < maxGear and (speed > gearSpeeds[newGear] * gearUpBuffer or rpm > upshiftRPM) then
            newGear = newGear + 1
        elseif newGear > minGear and (speed < gearSpeeds[newGear - 1] * gearDownBuffer and rpm < powerMin) then
            newGear = newGear - 1
        end
    end

    return newGear
end

local function applyOutputs()
    if not mainWL then return end

    lastGear = writeWireIfChanged(mainWL, "Gear", output_gear, lastGear)
    lastThrottle = writePortIfChanged("Throttle", output_throttle, lastThrottle)

    local lweld = outputLeftBrake > 0 and 1 or 0
    local rweld = outputRightBrake > 0 and 1 or 0

    lastLWeld = writePortIfChanged("LeftWeldLatch", lweld, lastLWeld)
    lastRWeld = writePortIfChanged("RightWeldLatch", rweld, lastRWeld)

    if canNeutralSteer then
        if not leftWL or not rightWL then return end

        lastLBrake = writeWirePairIfChanged(leftWL, "Left Brake", "Right Brake", outputLeftBrake, lastLBrake)
        lastRBrake = writeWirePairIfChanged(rightWL, "Left Brake", "Right Brake", outputRightBrake, lastRBrake)

        lastLClutch = writeWirePairIfChanged(leftWL, "Left Clutch", "Right Clutch", outputLeftClutch, lastLClutch)
        lastRClutch = writeWirePairIfChanged(rightWL, "Left Clutch", "Right Clutch", outputRightClutch, lastRClutch)

        if inlineTransfers then
            lastLGear = writeWireIfChanged(leftWL, "Gear", outputLeftGear, lastLGear)
            lastRGear = writeWireIfChanged(rightWL, "Gear", outputRightGear, lastRGear)
        else
            lastLGear = writeWirePairIfChanged(leftWL, "Left Gear", "Right Gear", outputLeftGear, lastLGear)
            lastRGear = writeWirePairIfChanged(rightWL, "Left Gear", "Right Gear", outputRightGear, lastRGear)
        end
    elseif dualClutch then
        lastLBrake = writeWireIfChanged(mainWL, "Left Brake", outputLeftBrake, lastLBrake)
        lastRBrake = writeWireIfChanged(mainWL, "Right Brake", outputRightBrake, lastRBrake)

        lastLClutch = writeWireIfChanged(mainWL, "Left Clutch", outputLeftClutch, lastLClutch)
        lastRClutch = writeWireIfChanged(mainWL, "Right Clutch", outputRightClutch, lastRClutch)
    else
        lastLBrake = writeWireIfChanged(mainWL, "Brake", outputLeftBrake, lastLBrake)
        lastLClutch = writeWireIfChanged(mainWL, "Clutch", outputLeftClutch, lastLClutch)
    end
end

local function updateEngineVariables()
    if not isValid(input_engine) or not isValid(input_mainGearbox) then
        engineReady = false
        return
    end

    powerMin = input_engine:acfPowerbandMin()
    powerMax = input_engine:acfPowerbandMax()

    biteRPM = powerMin * clutchStart
    releaseRPM = powerMin

    upshiftRPM = powerMax * 0.95
    downshiftRPM = powerMin * 0.85

    gearCount = input_mainGearbox:acfNumGears()
    reverseGears = 0
    for i = 1, gearCount do
        local ratio = input_mainGearbox:acfGearRatio(i)
        gears[i] = ratio
        if ratio < 0 then
            reverseGears = reverseGears + 1
        end
    end
    gearCount = gearCount - reverseGears
    isAutogearing = gearCount > 2

    acf3GearRatios = math.abs(input_mainGearbox:acfGearRatio(1)) > 1
    local commonVal = (powerMax * finalRatio / 60) * wheelSize * math.pi

    if isAutogearing then
        if showDebug then print("Gear Speeds:") end
        if acf3GearRatios then
            for i = 1, gearCount + reverseGears do
                gearSpeeds[i] = math.abs(commonVal * (1 / input_mainGearbox:acfGearRatio(i)) * SPEEDCONV)
                if showDebug then print("    " .. i .. " .. " .. gearSpeeds[i]) end
            end
        else
            for i = 1, gearCount + reverseGears do
                gearSpeeds[i] = math.abs(commonVal * (input_mainGearbox:acfGearRatio(i)) * SPEEDCONV)
                if showDebug then print("    " .. i .. " .. " .. gearSpeeds[i]) end
            end
        end
    end

    gearLinks = input_mainGearbox:acfLinks()
    leftTransfer = nil
    rightTransfer = nil
    leftWL = nil
    rightWL = nil
    canNeutralSteer = false

    local transfers = 0
    for i = 1, #gearLinks do
        if gearLinks[i]:getClass() == "prop_physics" then continue end
        local type = gearLinks[i]:acfType()
        if type == "Transfer Case" or type == "Transfer" then
            transfers = transfers + 1
            local y = input_mainGearbox:worldToLocal(gearLinks[i]:getPos()).y
            if y * invertedTransfers < 0 then rightTransfer = gearLinks[i] end
            if y * invertedTransfers > 0 then leftTransfer = gearLinks[i] end
        end
    end

    if transfers >= 2 then canNeutralSteer = true end
    mainWL = input_mainGearbox:getWirelink()
    if isValid(leftTransfer) then
        leftWL = leftTransfer:getWirelink()
    end
    if isValid(rightTransfer) then
        rightWL = rightTransfer:getWirelink()
    end
    engineReady = mainWL ~= nil

    if showDebug then
        if acf3GearRatios and isAutogearing then print("This Vehicle Uses ACF3 Gears") elseif isAutogearing then print("This vehicle Uses ACE Gears") end
        print("Detected Forward Gears .. " .. gearCount)
        print("Detected Reverse Gears .. " .. reverseGears)
        print("Detected Transfers .. " .. transfers)
        if isAutogearing then print("Autogearing Enabled") else print("Autogearing Disabled") end
        if canNeutralSteer then print("The Vehicle Can Neutral Steer") else print("The Vehicle Cannot Neutral Steer") end
    end
end

local function handleWire(name, value)
    if value == nil then return end
    if name == "Engine" then
        input_engine = value
    elseif name == "MainGearbox" then
        input_mainGearbox = value
    elseif name == "Base" then
        input_base = value
    elseif name == "Pod" then
        input_pod = value
    end

    if name == "Engine" or name == "MainGearbox" then
        updateEngineVariables()
    end
end

local function think()
    if not input_engine or not input_mainGearbox or not input_base or not input_pod then return end
    if not isValid(input_engine) or not isValid(input_mainGearbox) or not isValid(input_base) then return end
    if not engineReady then return end

    local vel = input_base:getVelocity()
    local speed = vel:getLength() * SPEEDCONV
    local rpm = input_engine:acfRPM()
    local W = input_pod["W"] or 0
    local A = input_pod["A"] or 0
    local S = input_pod["S"] or 0
    local D = input_pod["D"] or 0
    local driveDir = W - S
    local steerDir = D - A
    if invertSteer then
        steerDir = -steerDir
    end
    local neutralSteerEnabled = canNeutralSteer and not hasWheels and not disableNeutralSteer
    local nonNeutralSteerEnabled = not hasWheels and not neutralSteerEnabled
    local hasDriveInput = driveDir ~= 0
    local hasSteerInput = steerDir ~= 0
    local steerOnlyDrive = nonNeutralSteerEnabled and not hasDriveInput and hasSteerInput
    if steerOnlyDrive then
        driveDir = 1
    end
    local hasInput = hasDriveInput or (neutralSteerEnabled and hasSteerInput) or steerOnlyDrive

    outputLeftGear = 1
    outputRightGear = 1

    if not hasInput and speed < 1 and rpm < biteRPM then
        output_throttle = idleThrottle
        applyBrakeClutch(maxBrakePower, maxBrakePower, clutchBrake, clutchBrake)
        applyOutputs()
        return
    end

    local brakePower = maxBrakePower
    if brakeScaling then
        if isAutogearing and gearSpeeds[gearCount] and speed > 1 then
            brakePower = maxBrakePower * math.min(gearSpeeds[gearCount] / 2 / speed, 1)
        elseif speed > 1 then
            brakePower = maxBrakePower * math.min(BRAKE_SPEED_GATE / speed, 1)
        end
    end

    applyBrakeClutch(brakePower, brakePower, clutchBrake, clutchBrake)

    if hasInput then
        output_throttle = 100
        local clutchRelease = 1 - math.clamp((rpm - biteRPM) / (releaseRPM - biteRPM), 0, 1)
        applyBrakeClutch(0, 0, clutchRelease, clutchRelease)
    else
        output_throttle = idleThrottle
    end

    if driveDir == 0 then
        if output_gear > gearCount then
            driveDir = -1
        else
            driveDir = 1
        end
    end

    output_gear = selectGear(rpm, speed, driveDir, neutralSteerEnabled)

    if neutralSteerEnabled then
        if not hasDriveInput and hasSteerInput then
            if steerDir < 0 then
                outputLeftGear = 2
                outputRightGear = 1
            else
                outputLeftGear = 1
                outputRightGear = 2
            end
        else
            if driveDir < 0 then
                outputLeftGear = 2
                outputRightGear = 2
            end

            if steerDir < 0 then
                applyBrakeClutch(brakePower, 0, clutchTurn, outputRightClutch)
            elseif steerDir > 0 then
                applyBrakeClutch(0, brakePower, outputLeftClutch, clutchTurn)
            end
        end
    elseif nonNeutralSteerEnabled then
        if canNeutralSteer and driveDir < 0 and reverseGears == 0 then
            outputLeftGear = 2
            outputRightGear = 2
        end

        if hasSteerInput and (hasDriveInput or speed > 1 or steerOnlyDrive) and (canNeutralSteer or dualClutch) then
            local turnDir = steerDir
            if driveDir < 0 and invertReverseSteer then
                turnDir = -turnDir
            end

            if turnDir > 0 then
                outputRightBrake = math.max(outputRightBrake, brakePower)
                outputRightClutch = math.max(outputRightClutch, clutchTurn)
            else
                outputLeftBrake = math.max(outputLeftBrake, brakePower)
                outputLeftClutch = math.max(outputLeftClutch, clutchTurn)
            end
        end
    end

    if not hasWheels and hasDriveInput and not hasSteerInput then
        local yawRate = input_base:getAngleVelocity().z
        if math.abs(yawRate) > yawDeadzone then
            local counterSteerWeight = math.min(
                math.abs(yawRate) / MAX_YAW_RATE * counterSteerStrength,
                1
            ) * brakePower
            local direction = driveDir ~= 0 and driveDir or 1
            if invertSteer then
                direction = -direction
            end

            if yawRate * direction < 0 then
                outputLeftBrake = math.max(outputLeftBrake, counterSteerWeight)
                outputLeftClutch = math.max(outputLeftClutch, clutchTurn)
            else
                outputRightBrake = math.max(outputRightBrake, counterSteerWeight)
                outputRightClutch = math.max(outputRightClutch, clutchTurn)
            end
        end
    end

    applyOutputs()
end

--- Hooks
wire.adjustPorts(
    {Engine = "entity", MainGearbox = "entity", Base = "entity", Pod = "wirelink"},
    {Throttle = "number", LeftWeldLatch = "number", RightWeldLatch = "number"}
)
hook.add("input", "Wire Inputs Updated", handleWire)
timer.create("Main Logic Loop", 0.05, 0, think)
