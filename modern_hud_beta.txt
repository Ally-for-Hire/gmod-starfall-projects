--@name Modern HUD Beta
--@author Ally for Hire / Merydian9
--@include allylib/helpful_hud_functions.txt
--@include allylib/animation_class.txt
--@model models/sprops/rectangles_thin/size_1/rect_3x3x1_5.mdl
--@shared

--- Version 0.8.2
-- Sourced from https://github.com/Ally-for-Hire/gmod-script-projects/blob/main/huds_and_displays/modern_hud_beta.txt
-- GITHUB: https://github.com/Ally-for-Hire/gmod-script-projects/tree/main
-- GOOGLE DRIVE: https://drive.google.com/drive/folders/1arb3QgrZkKfF06vdEVqD4samK23IfJrT?dmr=1&ec=wgc-drive-globalnav-goto

-- Shared space
local SELF = chip()
local REFRESHRATE = 500
local LIB = require("allylib/helpful_hud_functions.txt")
local ANIMLIB = require("allylib/animation_class.txt")

if CLIENT then
    --if player() ~= owner() then return end
    
    -- Variable Declaration
    local input_base, input_turret = chip(), chip()
    local input_mainGun, input_guns = chip(), {}
    
    local engine_RPM, gearbox_gear, engine_fuel = 0, 0, 0

    local input_position, input_velocity, input_ids, input_owner, input_time = {}, {}, {}, {}, {}
    local input_targetPos, input_targetVel, input_targetID, input_targetName = Vector(), Vector(), -1, "UNDEFINED"
    local input_leadPos = Vector()

    local resx, resy, x, y = 0, 0, 0, 0
    local hasMultipleGuns, hasMainGun, hasEngineInfo = 0, 0, 0
    local showLeadPos, detectsAmmoTypes = false, false
    local showsRadarData, showsTargetTrack = false, false
    local crosshairType, mainColor, outlineColor = 0, Color(255, 255, 255), Color(0, 0, 0)
    local maxElevation, maxDepression = 0, 0

    local staticDrawn = false
    local lastUpdate = timer.curtime()
    local internal_times = {}
    local eyePos, aimDir = Vector(), Vector()
    local speed = 0
    local lastHUDUpdate = timer.curtime()
    
    local mainGunReady = false
    local mainGunRound = ""
    local mainGunStatus = ""
    local mainGunReloadProgress = 0
    local mainGunReloadTime = 0
    local gunInformation = {}

    local FONT_MAIN = render.createFont("Trebuchet24", 15, 1200, nil, nil, nil, true)
    local FONT_MAIN_NOOUTLINE = render.createFont("Trebuchet24", 15, 1200, nil, nil, nil, false)
    local FONT_BIG = render.createFont("Trebuchet24", 25, 1200, nil, nil, nil, true)
    local targetBoxGen = initRT("General Target Box")
    local targetBoxMain = initRT("Main Target Box")
    local tankIcon = initRT("Tank Aiming Icon")
    local crosshairRT = initRT("Crosshair")
    local headingRT = initRT("Heading1")
    local headingBracket = initRT("Heading Bracket")
    local gunReticle = initRT("Gun Reticle")
    local gunCircleRT = initRT("Gun Circle")
    
    local gunInfoBracket = initRT("Gun Info Bracket")
    local cannonIcon = initRT("Cannon Icon")
    local mgIcon = initRT("MG Icon")
    local smokeIcon = initRT("SM Icon")
    
    --- Needed Information:
    /*
    - Armor Information (Possibley listing everything lost like GHPC or WT?)
    */

    --- Known Information:
    /*
    - Lead Position

    - ID, Time of Radar Data
    - Position, Velocity, ID, Name of Target 
    - Elevation, Depression
    */

    --- Displayed Information:
    /*
    - Positions, Velocity, Owner of Radar Data
    - Base Angles
    - Main Gun Angles
    - Engine RPM
    - Gear
    - Fuel
    - Speed
    - Gun End Point
    - Gun Names
    - Gun Statuses
    - Gun Ammo Counts
    - Smoke Ammo and Ready
    */

    -- Functionality
    local function doHud()
        if (timer.curtime() - lastHUDUpdate) < (1 / REFRESHRATE) then return end
        lastHUDUpdate = timer.curtime()
        
        resx, resy = render.getResolution()
        x, y = resx / 2, resy / 2
        eyePos = render.getEyePos()
        aimDir = render.getEyeVector()
        
        if hasMainGun then
            local mainGunTrace = trace.line(input_mainGun:getPos() + input_mainGun:getForward() * 300, input_mainGun:getPos() + input_mainGun:getForward() * 999999)
            local coords = mainGunTrace["HitPos"]:toScreen()
            m = Matrix()
            m:translate(Vector(coords.x, coords.y, 0))
            m:scale(Vector(0.5))
            render.pushMatrix(m)
                drawCenterRT(0, 0, gunCircleRT)
            render.popMatrix()
            
            font(FONT_BIG)
            local textX, textY = x, y * 1.25
            text(textX, textY, mainGunRound, TEXT_ALIGN.CENTER)
            local leftright = render.getTextSize(mainGunRound)
            
            color(outlineColor)
            drawCenterRect(textX, textY + 25, leftright * 1.5, 3)
            color(mainColor)
            drawCenterRect(textX, textY + 25, leftright * 1.5 - 1, 1)
            
            font(FONT_MAIN)
            if mainGunReady then
                drawCenterRT(coords.x, coords.y, gunReticle)
                text(textX, textY + 30, mainGunStatus, TEXT_ALIGN.CENTER)
            else
                text(textX, textY + 30, mainGunStatus .. " .. " .. math.round(mainGunReloadTime - (mainGunReloadTime * mainGunReloadProgress), 1) .. "s", TEXT_ALIGN.CENTER)
            end

            local relativePitch = input_base:getAngles().p - input_mainGun:getAngles().p
        end
        
        -- Multi Target Display
        if showsRadarData then
            local theTime = timer.curtime()
            font(FONT_MAIN)
            for k, v in pairs(internal_times) do
                local pos = v.pos
                local vel = v.vel
                local name = v.owner
                local id = k
                local dt = (theTime - v.time)
                
                anim = ANIMATION:get({
                    id = k,
                    startV = 3,
                    endV = 1,
                    duration = 0.5,
                    easing = makeEaseInLog(12)
                })
                
                if dt > 8 then internal_times[k] = nil; anim:delete(); continue end
                
                local progress = anim:getValue()
                
                local _p = (pos + vel * (dt + 0.01)):toScreen()
                local _pv = (pos + vel * (dt + 0.21)):toScreen()
                
                local lineTestEnd = getPoint(x, y, _p.x, _p.y, 200)
                local lineDist = math.sqrt((_p.x - lineTestEnd.x)^2 + (_p.y - lineTestEnd.y)^2)
                local distance = (60 - math.clamp(lineDist, 0, 60))
                local lineLength = 25 - distance
                
                if dt > 4 then color(Color(0, 0, 0, timer.curtime() * 400 % 200))
                else color(outlineColor) end
                spacedLine(_p.x, _p.y, _pv.x, _pv.y, 10, 0, 3)
                local lineEnd = getPoint(x, y, _p.x, _p.y, 175 + lineLength)
                spacedLine(x, y, lineEnd.x, lineEnd.y, 175, 0, 4)
                line(_p.x-20*progress, _p.y-8.5, _p.x-20*progress, _p.y+8.5, 4)
                line(_p.x+20*progress, _p.y-8.5, _p.x+20*progress, _p.y+8.5, 4)
                
                if dt > 4 then color(Color(255, 255, 255, timer.curtime() * 400 % 200))
                else color(mainColor) end
                spacedLine(_p.x, _p.y, _pv.x, _pv.y, 10, 0)
                local lineEnd = getPoint(x, y, _p.x, _p.y, 174 + lineLength)
                spacedLine(x, y, lineEnd.x, lineEnd.y, 176, 0, 2)
                line(_p.x-20*progress, _p.y-7.5, _p.x-20*progress, _p.y+7.5, 2)
                line(_p.x+20*progress, _p.y-7.5, _p.x+20*progress, _p.y+7.5, 2)
                text(_p.x, _p.y + 15, name .. " *" .. id, TEXT_ALIGN.CENTER)
            end
        end

        -- Single Target Display
        if input_targetPos ~= Vector() then
            -- Stuff Here
        end

        -- Engine Info Display
        if hasEngineInfo then
            local engX, engY = x - 105, y * 2 - 60
            
            color(outlineColor)
            --centerRectOutline(engX, engY, 55, 55, 3)
            --rectOutline(engX + 35, engY - 55 / 2, 195, 55, 3)
            drawPlus(engX + 25, engY + 25, 10, 0, 10, 0, 3)
            drawPlus(engX + 25, engY - 25, 0, 10, 10, 0, 3)
            drawPlus(engX - 25, engY + 25, 10, 0, 0, 10, 3)
            drawPlus(engX - 25, engY - 25, 0, 10, 0, 10, 3)
            centerRect(engX + 35, engY, 3, 50)
            centerRect(engX + 35 + 5, engY + 25, 10, 3)
            centerRect(engX + 35 + 5, engY - 25, 10, 3)
            centerRect(engX + 230, engY, 3, 50)
            centerRect(engX + 230 - 5, engY + 25, 10, 3)
            centerRect(engX + 230 - 5, engY - 25, 10, 3)
            
            color(mainColor)
            --centerRectOutline(engX, engY, 53, 53, 1)
            --rectOutline(engX + 36, engY - 55 / 2 + 1, 193, 53, 1)
            drawPlus(engX + 25, engY + 25, 10, 0, 10, 0, 1)
            drawPlus(engX + 25, engY - 25, 0, 10, 10, 0, 1)
            drawPlus(engX - 25, engY + 25, 10, 0, 0, 10, 1)
            drawPlus(engX - 25, engY - 25, 0, 10, 0, 10, 1)
            centerRect(engX + 35, engY, 1, 49)
            centerRect(engX + 35 + 5, engY + 25, 10, 1)
            centerRect(engX + 35 + 5, engY - 25, 10, 1)
            centerRect(engX + 230, engY, 1, 49)
            centerRect(engX + 230 - 5, engY + 25, 10, 1)
            centerRect(engX + 230 - 5, engY - 25, 10, 1)
            local m = Matrix()
            m:translate(Vector(engX, engY, 0 ))
            m:rotate(Angle(0, aimDir:getAngle().y - input_base:getAngles().y, 0 ))
            render.pushMatrix(m)
                color(outlineColor)
                centerRectOutline(0, 0, 27, 42, 3)
                color(mainColor)
                centerRectOutline(0, 0, 25, 40, 1)
            render.popMatrix()
            m = Matrix()
            m:translate(Vector(engX, engY, 0 ))
            m:rotate(Angle(0, aimDir:getAngle().y - input_mainGun:getAngles().y, 0 ))
            render.pushMatrix(m)
                drawCenterRT(0, 0, tankIcon)
            render.popMatrix()
            
            font(FONT_MAIN)
            text(engX + 45, engY - 20, "GEAR")
            text(engX + 110, engY - 20, gearbox_gear, TEXT_ALIGN.RIGHT)
            text(engX + 45, engY + 20 - 15, "RPM" )
            text(engX + 110, engY + 20 - 15, math.round(engine_RPM), TEXT_ALIGN.RIGHT)
            text(engX + 130, engY - 20, "SPEED")
            text(engX + 220, engY - 20, math.round(speed) .. "KMH", TEXT_ALIGN.RIGHT)
            text(engX + 130, engY + 20 - 15, "FUEL")
            text(engX + 220, engY + 20 - 15, math.round(engine_fuel) .. "L", TEXT_ALIGN.RIGHT)
        end
        
        local heading = aimDir:getAngle().y 
        local headX, headY = x, 60
        
        color(mainColor)
        render.enableScissorRect(headX - 512, headY - 40, headX + 512, headY + 40)
            drawCenterRT(headX + 512 + 1024 * (heading / 360), headY, headingRT)
            drawCenterRT(headX - 1536 + 1024 * (heading / 360), headY, headingRT)
            drawCenterRT(headX - 512 + 1024 * (heading / 360), headY, headingRT)
        render.disableScissorRect()
        
        color(outlineColor)
        line(headX + 10, headY - 35, headX, headY - 25, 3)
        line(headX - 10, headY - 35, headX, headY - 25, 3)
        centerRect(headX - 25, headY + 17.5, 3, 15)
        centerRect(headX + 25, headY + 17.5, 3, 15)
        
        color(mainColor)
        line(headX + 10, headY - 35, headX, headY - 25, 1)
        line(headX - 10, headY - 35, headX, headY - 25, 1)
        centerRect(headX - 25, headY + 17.5, 1, 13)
        centerRect(headX + 25, headY + 17.5, 1, 13)
        drawCenterRT(headX - 512, headY, headingBracket)
        m = Matrix()
        m:translate(Vector(headX + 512, headY - 15, 0 ))
        m:rotate(Angle(0, 180, 0 ))
        render.pushMatrix(m)
            drawCenterRT(0, 0, headingBracket)
        render.popMatrix()
        font(FONT_MAIN)
        text(headX, headY + 40, math.round(90 / player():getFOV(), 2) .. "x ZOOM", TEXT_ALIGN.CENTER)
        
        --centerRectOutline(headX, headY - 10, 1028, 28, 1)
        font(FONT_BIG)
        text(headX, headY + 5, math.round(heading), TEXT_ALIGN.CENTER)
        --centerRectOutline(headX, headY + 17.5, 48, 23)
        
        local gunInfoX, gunInfoY = x * 2 - 60, y * 2 - 30
        local smokes = 0
        local subtract = 0
        for k, v in pairs(gunInformation) do
            local curPosY = gunInfoY - 65 * (v.i - subtract)
            if v.type == "Smoke Launcher" then
                color(mainColor)
                drawCenterRT(gunInfoX - 320 - 70 * smokes, gunInfoY, gunInfoBracket)
                m = Matrix()
                m:translate(Vector(gunInfoX - 370 - 70 * smokes, gunInfoY, 0))
                m:rotate(Vector(0, 180, 0))
                render.pushMatrix(m)
                    drawCenterRT(0, 0, gunInfoBracket)
                render.popMatrix()
                
                color(v.ready and mainColor or outlineColor)
                drawCenterRT(gunInfoX - 350 - 70 * smokes, gunInfoY, smokeIcon)
                color(mainColor)
                font(FONT_MAIN)
                text(gunInfoX - 325 - 70 * smokes, gunInfoY, "x" .. v.totalRounds, TEXT_ALIGN.RIGHT)

                --subtract = subtract + 1
                smokes = smokes + 1
                continue
            end
            color(mainColor)
            drawCenterRT(gunInfoX, curPosY, gunInfoBracket)
            
            m = Matrix()
            m:translate(Vector(gunInfoX-300, curPosY, 0))
            m:rotate(Vector(0, 180, 0))
            render.pushMatrix(m)
                drawCenterRT(0, 0, gunInfoBracket)
            render.popMatrix()
            
            font(FONT_BIG)
            text(gunInfoX - 60, curPosY - 12.5 - 7.5, v.magRounds, TEXT_ALIGN.RIGHT)
            font(FONT_MAIN)
            text(gunInfoX - 60, curPosY - 7.5 - 7.5, " // " .. v.totalRounds, TEXT_ALIGN.LEFT)
            text(gunInfoX - 60, curPosY - 7.5 + 7.5, v.caliber .. "MM " .. v.ammoType, TEXT_ALIGN.RIGHT)
            
            color(v.ready and mainColor or outlineColor)
            font(v.ready and FONT_MAIN or FONT_MAIN_NOOUTLINE)
            text(gunInfoX - 60, curPosY - 7.5 + 7.5, " READY", TEXT_ALIGN.LEFT)
            
            font(FONT_BIG)
            --color(mainColor)
            if v.type == "Cannon" or v.type == "Smooth-Bore Cannon" then
                drawCenterRT(gunInfoX - 220, curPosY, cannonIcon)
            elseif v.type == "Machinegun" then
                drawCenterRT(gunInfoX - 230, curPosY, mgIcon)
            else
                text(gunInfoX - 120, curPosY - 12.5, string.upper(v.type), TEXT_ALIGN.RIGHT)
            end
        end

        color(mainColor)
        drawCenterRT(x, y, crosshairRT)
    end

    local function doStaticElements()
        local x, y = 512, 512
        -- Grouped elements that need updates go here

        if staticDrawn then return end
        -- Static elements that don't need updates go here
        selectClearRT(targetBoxGen)
            local m = Matrix()
            m:translate(Vector(x, y, 0 ))
            render.pushMatrix(m)
                color(outlineColor)
                line(-20, -8.5, -20, 8.5, 4)
                line(20, -8.5, 20, 8.5, 4)
                
                color(mainColor)
                line(-20, -7.5, -20, 7.5, 2)
                line(20, -7.5, 20, 7.5, 2)
            render.popMatrix()

        selectClearRT(targetBoxMain)
            color(outlineColor)
            centerRectOutline(x, y, 23, 23, 3)
            
            color(mainColor)
            centerRectOutline(x, y, 20, 20) 

        selectClearRT(tankIcon)
            color(outlineColor)
            line(x + 10, y - 5, x + 10, y + 15, 3)
            line(x + 10, y - 5, x, y - 15, 3)
            line(x, y - 15, x - 10, y - 5, 3)
            line(x - 10, y - 5, x - 10, y + 15, 3)
            line(x - 10, y + 15, x + 10, y + 15, 3)
            line(x, y, x, y-25, 3)
            
            color(mainColor)
            line(x + 10, y - 5, x + 10, y + 15, 1)
            line(x + 10, y - 5, x, y - 15, 1)
            line(x, y - 15, x - 10, y - 5, 1)
            line(x - 10, y - 5, x - 10, y + 15, 1)
            line(x - 10, y + 15, x + 10, y + 15, 1)
            line(x, y, x, y-25, 1)

        selectClearRT(crosshairRT)
            if crosshairType == 1 then
                color(outlineColor)
                drawPlus(x, y, 15, 4)
                color(mainColor)
                drawPlus(x, y, 14, 2)
                
            elseif crosshairType == 2 then 
                color(outlineColor)
                circle(x, y, 15, 2)
                circle(x, y, 11, 2)
                color(mainColor)
                circle(x, y, 13, 2)
                
            elseif crosshairType == 3 then 
                color(outlineColor)
                render.drawFilledCircle(x, y, 3)
                color(mainColor)
                render.drawFilledCircle(x, y, 2)
                
            elseif crosshairType == 4 then
                color(outlineColor)
                line(x, y, x + 15.5, y + 20.75, 4.5)
                line(x, y, x - 15.5, y + 20.75, 4.5)
                line(x, y + 9, x, y + 60, 4)
                centerRect(x, y + 60, 62, 4)
                line(x + 14, y, x + 31, y, 4)
                line(x - 14, y, x - 31, y, 4)
                line(x, y - 14, x, y - 31, 4)
                
                color(mainColor)
                line(x, y, x + 15, y + 20, 2)
                line(x, y, x - 15, y + 20, 2)
                line(x, y + 10, x, y + 60, 2)
                centerRect(x, y + 60, 60, 2)
                line(x + 15, y, x + 30, y, 2)
                line(x - 15, y, x - 30, y, 2)
                line(x, y - 15, x, y - 30, 2)
                
            elseif crosshairType == 5 then
                color(outlineColor)
                render.drawFilledCircle(x, y, 2.5)
                line(x, y + 4, x, y + 11, 4)
                line(x, y - 4, x, y - 11, 4)
                line(x + 4, y, x + 16, y, 4)
                line(x - 4, y, x - 16, y, 4)
                
                line(x + 29, y, x + 51, y, 4)
                line(x - 29, y, x - 51, y, 4)
                line(x + 69, y, x + 121, y, 4)
                line(x - 69, y, x - 121, y, 4)
                
                line(x, y + 19, x, y + 31, 4)
                line(x, y - 19, x, y - 31, 4)
                line(x, y + 39, x, y + 71, 4)
                line(x, y - 39, x, y - 71, 4)
                
                color(mainColor)
                render.drawFilledCircle(x, y, 1)
                line(x, y + 5, x, y + 10, 2)
                line(x, y - 5, x, y - 10, 2)
                line(x + 5, y, x + 15, y, 2)
                line(x - 5, y, x - 15, y, 2)
                
                line(x + 30, y, x + 50, y, 2)
                line(x - 30, y, x - 50, y, 2)
                line(x + 70, y, x + 120, y, 2)
                line(x - 70, y, x - 120, y, 2)
                
                line(x, y + 20, x, y + 30, 2)
                line(x, y - 20, x, y - 30, 2)
                line(x, y + 40, x, y + 70, 2)
                line(x, y - 40, x, y - 70, 2)
            end
        
        selectClearRT(headingRT)
            color(mainColor)
            for i = 0, 12 do
                if (i * 30) % 90 == 0 then 
                    font(FONT_BIG)
                    local txt = 360 - i * 30
                    if (360 - i * 30 == 0 or 360 - i * 30 == 360) then txt = 0 end
                    text(i * (1012/12)+5, y-22.5, txt, TEXT_ALIGN.CENTER)
                else 
                    font(FONT_MAIN)
                    color(outlineColor)
                    line(i * (1012/12)+5, y - 12.5, i * (1012/12)+5, y - 2.5, 3)
                    color(mainColor)
                    line(i * (1012/12)+5, y - 12.5, i * (1012/12)+5, y - 2.5, 1) 
                end
            end
            for i = 0, 12 do
                local lineX = i * (1012/12)+5 + (1012/12) / 2
                color(outlineColor)
                line(lineX, y - 12.5, lineX, y - 2.5, 3)
                color(mainColor)
                line(lineX, y - 12.5, lineX, y - 2.5, 1)
            end

        selectClearRT(headingBracket)
            color(outlineColor)
            centerRect(x, y - 7.5, 3, 25)
            centerRect(x + 6, y - 7.5 - 12.5, 12, 3)
            centerRect(x + 6, y + 7.5 - 2.5, 12, 3)
            color(mainColor)
            centerRect(x, y - 7.5, 1, 25)
            centerRect(x + 6, y - 7.5 - 12.5, 12, 1)
            centerRect(x + 6, y + 7.5 - 2.5, 12, 1)
            
        selectClearRT(gunReticle)
            color(outlineColor)
            line(x-6, y, x+6, y, 4)
            line(x, y-6, x, y+6, 4)
            --circle(x, y, 9, 3)
            
            color(mainColor)
            line(x-5, y, x+5, y, 2)
            line(x, y-5, x, y+5, 2)
            --circle(x, y, 10)
        
        selectClearRT(gunCircleRT)
                color(outlineColor)
                circle(x, y, 18, 6)
                color(mainColor)
                circle(x, y, 20, 2)
        
        selectClearRT(cannonIcon)
            color(outlineColor)
            drawCenterRect(x, y, 48, 23)
            drawCenterRect(x + 35, y, 18, 23)
            render.drawTriangle(x - 22.5, y + 11.5, x - 67, y, x - 22.5, y - 11.5)
            
            color(mainColor)
            drawCenterRect(x, y, 45, 20)
            drawCenterRect(x + 35, y, 15, 20)
            render.drawTriangle(x - 22.5, y + 10, x - 65, y, x - 22.5, y - 10)
            
        selectClearRT(mgIcon)
            color(outlineColor)
            drawCenterRect(x, y + 12, 47, 10.5)
            drawCenterRect(x, y, 47, 10.5)
            drawCenterRect(x, y - 12, 47, 10.5)
            drawCenterRect(x + 30, y + 12, 7, 10.5)
            drawCenterRect(x + 30, y, 7, 10.5)
            drawCenterRect(x + 30, y - 12, 7, 10.5)
            render.drawTriangle(x - 27, y + 12 + 4.25, x - 52, y + 12, x - 27, y + 12 - 4.25)
            render.drawTriangle(x - 27, y + 4.25, x - 52, y, x - 27, y - 4.25)
            render.drawTriangle(x - 27, y - 12 + 4.25, x - 52, y - 12, x - 27, y - 12 - 4.25)
            
            color(mainColor)
            drawCenterRect(x, y + 12, 45, 7.5)
            drawCenterRect(x, y, 45, 7.5)
            drawCenterRect(x, y - 12, 45, 7.5)
            drawCenterRect(x + 30, y + 12, 5, 7.5)
            drawCenterRect(x + 30, y, 5, 7.5)
            drawCenterRect(x + 30, y - 12, 5, 7.5)
            render.drawTriangle(x - 27.5, y + 12 + 3.25, x - 50, y + 12, x - 27.5, y + 12 - 3.25)
            render.drawTriangle(x - 27.5, y + 3.25, x - 50, y, x - 27.5, y - 3.25)
            render.drawTriangle(x - 27.5, y - 12 + 3.25, x - 50, y - 12, x - 27.5, y - 12 - 3.25)
            
        selectClearRT(gunInfoBracket)
            color(outlineColor)
            drawCenterRect(x, y, 3, 35)
            drawCenterRect(x-5, y-17.5, 10, 3)
            drawCenterRect(x-5, y+17.5, 10, 3)
            color(mainColor)
            drawCenterRect(x, y, 1, 34)
            drawCenterRect(x-5, y-17.5, 8, 1)
            drawCenterRect(x-5, y+17.5, 8, 1)
            
        selectClearRT(smokeIcon)
            m = Matrix()
            m:translate(Vector(x, y, 0))
            m:rotate(Angle(0, 45, 0))
            render.pushMatrix(m)
                color(outlineColor)
                drawCenterRect(0, 0, 10, 23)
                drawCenterRect(0, -15, 10, 5)
                
                color(mainColor)
                drawCenterRect(0, 0, 10, 22)
                drawCenterRect(0, -15, 10, 2)
            render.popMatrix()

        staticDrawn = true
    end
    
    -- Functions for processing incoming data
    local function processFastSend()
        if showsRadarData then
            local count = net.readInt(16)
            local new_positions, new_velocities, new_owners, new_ids = {}, {}, {}, {}
            
            for i = 1, count do
                new_positions[i] = net.readVector()
                new_velocities[i] = net.readVector()
                new_owners[i] = net.readString()
                new_ids[i] = net.readInt(16)
            end

            for i = 1, count do
                if input_position[i] ~= new_positions[i] then
                    internal_times[new_ids[i]] = {}
                    internal_times[new_ids[i]].pos = new_positions[i]
                    internal_times[new_ids[i]].vel = new_velocities[i]
                    internal_times[new_ids[i]].owner = new_owners[i]
                    internal_times[new_ids[i]].time = timer.curtime()
                end
            end
            
            input_position, input_velocity, input_owner, input_ids =
                new_positions, new_velocities, new_owners, new_ids
        end

        if showsTargetTrack then
            input_targetPos = net.readVector()
            input_targetVel = net.readVector()
            input_targetID = net.readInt(32)
            input_targetName = net.readString()
        end

        if showLeadPos then
            input_leadPos = net.readVector()
        end
        
        speed = net.readFloat()
        
        if hasMainGun and input_mainGun ~= chip() and input_mainGun ~= nil then
            mainGunReady = net.readBool()
            mainGunRound = net.readString()
            mainGunStatus = string.upper(net.readString())
            mainGunReloadTime = net.readFloat()   
            mainGunReloadProgress = net.readFloat()  
        end
    end
    local function processSlowSend()
         if hasEngineInfo then
            engine_RPM = net.readInt(32)
            gearbox_gear = net.readInt(16)
            engine_fuel = net.readInt(16)
        end
        if hasMultipleGuns then
            gunInformation = {}
            for i = 1, #input_guns do
                local gun = input_guns[i]
                gunInformation[gun] = {}
                gunInformation[gun].type = net.readString()
                gunInformation[gun].caliber = net.readInt(16)
                gunInformation[gun].ammoType = net.readString()
                gunInformation[gun].magRounds = net.readInt(16)
                gunInformation[gun].totalRounds = net.readInt(16)
                gunInformation[gun].ready = net.readBool()
                gunInformation[gun].i = net.readInt(16)
            end    
        end
    end
    local function processStaticSend()
        hasMultipleGuns = net.readBool()
        hasMainGun = net.readBool()
        maxElevation = net.readInt(16)
        maxDepression = net.readInt(16)
        hasEngineInfo = net.readBool()
        input_base = net.readEntity()
        input_turret = net.readEntity()
        if hasMultipleGuns then input_guns = net.readTable(); input_mainGun = input_guns[1] end
        if hasMainGun then input_mainGun = net.readEntity(); input_guns[1] = input_mainGun end
        showsRadarData = net.readBool()
        showsTargetTrack = net.readBool()
        crosshairType = net.readInt(16)
        detectsAmmoTypes = net.readBool()
        mainColor = net.readColor()
        outlineColor = net.readColor()
        staticDrawn = false
    end
    
    -- Hooks and Net Receives
    hook.add("drawhud", "MHB - Drawhud", doHud)
    hook.add("renderoffscreen", "MHB - Renderoffscreen", doStaticElements)
    hook.add("HUDShouldDraw", "Hide HUD", function(name) 
    if not (name == "CHudHealth" or name == "CHudBattery") then return end
        return false
    end)
    net.receive("MHB - Fast Send", processFastSend)
    net.receive("MHB - Slow Send", processSlowSend)
    net.receive("MHB - Static Send", processStaticSend)
elseif SERVER then
    -- Variable Declaration and Wire Initialization
    local input_base, input_turret, input_engine = chip(), chip(), chip()
    local input_mainGun, input_guns = chip(), {}
    local gearbox_gear, engine_fuel = 0, 0

    local input_position, input_velocity, input_ids, input_owner, input_time = {}, {}, {}, {}, {}
    local input_targetPos, input_targetVel, input_targetID, input_targetName = {}, {}, {}, {}
    local input_leadPos = Vector()
    
    local lastSlowSend, lastStaticSend = 0, 0
    local inputs = {DATA = "TABLE"}
    local outputs = {}
    if #wire.getInputs(chip()) == 0 then
        wire.adjustPorts(inputs, outputs)
    end
    
    local hasMultipleGuns, hasMainGun, hasEngineInfo = false, false, false
    local maxElevation, maxDepression = 0, 0
    local showsRadarData, showsTargetTrack = false, false
    local crosshairType, mainColor, outlineColor = 0, Color(255, 255, 255), Color(0, 0, 0)
    local hasLeadPos, detectsAmmoTypes = false, false
    
    -- Function for defining the chip's initial values and inputs and handling wire inputs
    local function doWire(name, value)
        if value == nil or value == entity(-1) then return end

        if name == "DATA" then 
            if table.count(value) == 0 then return end

            if value["HasMultipleGuns"] == 1 then
                inputs["Guns"] = "Array"
                hasMultipleGuns = true
            end
            if value["HasMainGun"] == 1 then
                hasMainGun = true
                if not hasMultipleGuns then
                    inputs["MainGun"] = "Entity"
                end
            end
            if value["HasEngineInfo"] == 1 then
                inputs["Engine"] = "Entity"
                inputs["Fuel"] = "Number"
                inputs["Gear"] = "Number"
                hasEngineInfo = true
            end
            if value["ShowRadarData"] == 1 then
                inputs["Position"] = "Array"
                inputs["Velocity"] = "Array"
                inputs["IDs"] = "Array"
                inputs["Owner"] = "Array"
                inputs["Time"] = "Array"
                showsRadarData = true
            end
            if value["ShowTargetTrack"] == 1 then
                inputs["TargetName"] = "String"
                inputs["TargetPos"] = "Vector"
                inputs["TargetVel"] = "Vector"
                inputs["TargetID"] = "Number"
                showsTargetTrack = true
            end
            if value["ShowLeadPosition"] == 1 then
                inputs["LeadPos"] = "Vector"
                hasLeadPos = true
            end
            crosshairType = value["CrosshairType"]
            maxElevation = value["Elevation"]
            maxDepression = value["Depression"]
            detectsAmmoTypes = value["DetectAmmoTypes"] == 1
            local cT = value["MainColor"]
            mainColor = Color(cT[1], cT[2], cT[3], cT[4])
            local bT = value["OutlineColor"]
            outlineColor = Color(bT[1], bT[2], bT[3], bT[4])
            print(outlineColor)
            inputs["Base"] = "Entity"
            inputs["Turret"] = "Entity"
            
            wire.adjustPorts(inputs, outputs)
        elseif name == "Base" then input_base = value
        elseif name == "Turret" then input_turret = value
        elseif name == "Engine" then input_engine = value
        elseif name == "Guns" then input_guns = value; input_mainGun = input_guns[1]
        elseif name == "MainGun" then input_mainGun = value; input_guns[1] = input_mainGun
        
        elseif name == "Gear" then gearbox_gear = value
        elseif name == "Fuel" then engine_fuel = value
        
        elseif name == "Position" then input_position = value
        elseif name == "Velocity" then input_velocity = value
        elseif name == "IDs" then input_ids = value
        elseif name == "Owner" then input_owner = value
        elseif name == "Time" then input_time = value
        
        elseif name == "TargetPos" then input_targetPos = value
        elseif name == "TargetVel" then input_targetVel = value
        elseif name == "TargetID" then input_targetID = value
        elseif name == "TargetName" then input_targetName = value

        elseif name == "LeadPos" then input_leadPos = value
        end
    end
    
    -- Function for interfacing all of the data with the client at the various speeds, works in 0.1s intervals
    local function doClientSends()
        local theTime = curtime()
        
        net.start("MHB - Fast Send")
            if showsRadarData then
                net.writeInt(#input_position, 16)
                for i = 1, #input_position do
                    net.writeVector(input_position[i])
                    net.writeVector(input_velocity[i])
                    net.writeString(input_owner[i])
                    net.writeInt(input_ids[i], 16)
                end
            end

            if showsTargetTrack then
                net.writeVector(input_targetPos)
                net.writeVector(input_targetVel)
                net.writeInt(input_targetID, 32)
                net.writeString(input_targetName)
            end

            if showLeadPos then
                net.writeVector(input_leadPos)
            end
            
            net.writeFloat(input_base:getVelocity():getLength() / 17.6)
            
            if hasMainGun and input_mainGun ~= chip() and input_mainGun ~= nil then
                net.writeBool(input_mainGun:acfReady())
                net.writeString(input_mainGun:acfAmmoType())
                net.writeString(input_mainGun:acfState())
                net.writeFloat(input_mainGun:acfReloadTime())
                net.writeFloat(input_mainGun:acfReloadProgress())
            end
        net.send(owner(), true)
        
        if (theTime - lastSlowSend) > 0.3 then
            net.start("MHB - Slow Send")
                if hasEngineInfo then
                    net.writeInt(input_engine ~= chip() and isValid(input_engine) and input_engine:acfRPM() or 0, 32)
                    net.writeInt(gearbox_gear, 16)
                    net.writeInt(engine_fuel, 16)
                end
                if hasMultipleGuns then
                    for i = 1, #input_guns do
                        local gun = input_guns[i]
                        net.writeString(gun:acfType())
                        net.writeInt(gun:acfCaliber(), 16)
                        net.writeString(gun:acfAmmoType())
                        net.writeInt(gun:acfMagRounds(), 16)
                        net.writeInt(gun:acfTotalAmmoCount(), 16)
                        net.writeBool(gun:acfReady())
                        net.writeInt(i - 1, 16)
                    end    
                end
            net.send(owner())
            lastSlowSend = theTime
        end 
        
        if (theTime - lastStaticSend) > 2 then
            net.start("MHB - Static Send")
                net.writeBool(hasMultipleGuns)
                net.writeBool(hasMainGun)
                net.writeInt(maxElevation, 16)
                net.writeInt(maxDepression, 16)
                net.writeBool(hasEngineInfo)
                net.writeEntity(input_base)
                net.writeEntity(input_turret)
                if hasMultipleGuns then net.writeTable(input_guns) end
                if hasMainGun then 
                    if isValid(input_mainGun) then net.writeEntity(input_mainGun) 
                    else net.writeEntity(chip()) end
                end
                net.writeBool(showsRadarData)
                net.writeBool(showsTargetTrack)
                net.writeInt(crosshairType, 16)
                net.writeBool(detectsAmmoTypes)
                net.writeColor(mainColor)
                net.writeColor(outlineColor)
            net.send(owner())
            lastStaticSend = theTime
        end
    end

    hook.add("input", "MHB - Wire Updates", doWire)
    timer.create("MHB - Interface", 0.05, 0, doClientSends)
end
