--@name Merydian's SF Gun Controller
--@author Ally for Hire / Merydian9
--@include allylib/simple_server-side_wire_helper.txt
--@include allylib/curve-fitting_ballistics_algorithm.txt
--@server

local curtime = timer.curtime
require("allylib/simple_server-side_wire_helper.txt")
require("allylib/curve-fitting_ballistics_algorithm.txt")

INTERVAL   = 0.05
GZ         = 600
LOAD_DIST  = 10000
LOAD_PITCH = nil
TARGET_LEAD_TIME = 0.02

NextThink  = 0
Unlocked   = false
LastGun    = nil
LastTargetVel  = Vector()
LastTargetTime = 0
TargetAccel    = Vector()
LastReady      = false
LastTargetDt   = 0
local zeroVec = Vector()

local function updateTargetAccel(tvel, now)
    if LastTargetTime <= 0 then
        LastTargetVel = tvel
        LastTargetTime = now
        TargetAccel = zeroVec
        return TargetAccel
    end

    local dt = now - LastTargetTime
    if dt <= 0 then
        TargetAccel = zeroVec
    else
        TargetAccel = (tvel - LastTargetVel) / dt
        LastTargetDt = dt
    end

    LastTargetVel = tvel
    LastTargetTime = now

    return TargetAccel
end

local function getBasePos(hit, tpos)
    if tpos:getLength() > 0 then
        return tpos
    end
    return hit
end

local function getLoadAimPos(gun, base, targetPos, loadAng)
    if not gun or not gun:isValid() then return nil end
    if not base or not base:isValid() then return nil end

    local origin = gun:getMassCenterW() or gun:getPos()
    local baseAng = base:getAngles()
    local toTarget = targetPos - origin
    local yaw = toTarget:getAngle().y
    local ang = Angle(baseAng.p - loadAng.p, yaw, 0)
    return origin + ang:getForward() * LOAD_DIST
end

local function getBallisticAimPos(gun, base, basePos, tvel, tacc)
    local gpos = gun:getMassCenterW() or gun:getPos()
    local dist = gpos:getDistance(basePos)
    local bvel  = base:getVelocity()
    local baseToGun = basePos - gpos
    local tta = 0

    local low = 0
    local high = 6
    local baseTime = ballisticTime and ballisticTime(dist) or 0
    if baseTime > 0 then
        high = baseTime * 1.5
        if high < 0.5 then high = 0.5 end
        if high > 6 then high = 6 end
    end
    local diffLow = nil
    local diffHigh = nil
    tta = (low + high) / 2

    local function evalDiff(t)
        local tSq = t * t
        local drop = Vector(0, 0, 0.5 * GZ * tSq)
        local accel = tacc * (0.5 * tSq)
        local tlen = (baseToGun + tvel * t + accel + drop):getLength()
        local slen = ballisticDistance(t)
        return slen - tlen
    end

    if not ballisticDistance then
        return basePos, 0
    end

    local slenHigh = ballisticDistance(high)
    if slenHigh <= 0 then
        return basePos, 0
    end

    diffLow = evalDiff(low)
    diffHigh = evalDiff(high)

    while high - low > 0.05 do
        local nextT = nil
        if diffLow and diffHigh and diffHigh ~= diffLow then
            local secant = high - diffHigh * (high - low) / (diffHigh - diffLow)
            if secant > low and secant < high then
                nextT = secant
            end
        end
        if not nextT then
            nextT = (low + high) / 2
        end

        local diff = evalDiff(nextT)
        if diff < 0 then
            low = nextT
            diffLow = diff
        else
            high = nextT
            diffHigh = diff
        end

        tta = (low + high) / 2
    end

    local drag = -bvel * tta
    local ttaSq = tta * tta
    local drop = Vector(0, 0, 0.5 * GZ * ttaSq)
    local accel = tacc * (0.5 * ttaSq)
    local aimPos = basePos + tvel * tta + accel + drag + drop
    return aimPos, tta
end

local function main()
    local now = curtime()
    if now < NextThink then return end
    NextThink = now + INTERVAL

    local gun    = Inputs.Gun:get()    or I.Gun
    local base   = Inputs.Base:get()
    local hit    = Inputs.HitPos:get() or Vector()
    local tpos   = Inputs.TargetPos:get() or Vector()
    local tvel   = Inputs.TargetVel:get() or Vector()
    local manual = (Inputs.M2:get()    or 0) ~= 0
    local loadEnabled = LOAD_PITCH ~= nil
    local loadAng = nil
    if loadEnabled then
        loadAng = Angle(LOAD_PITCH, 0, 0)
    end
    local gunValid = gun and gun:isValid()
    local baseValid = base and base:isValid()
    local ready = false
    if gunValid and gun.acfReady then
        ready = gun:acfReady()
    end
    if ready ~= LastReady then
        LastReady = ready
    end

    -- keep C-FBA in sync
    if gunValid and gun ~= LastGun and CFBA_SetGun then
        CFBA_SetGun(gun)
        LastGun = gun
    end

    local basePos = getBasePos(hit, tpos)
    local tacc = updateTargetAccel(tvel, now)

    local leadTime = LastTargetDt + TARGET_LEAD_TIME
    local leadSq = leadTime * leadTime
    local aimBasePos = basePos + tvel * leadTime + tacc * (0.5 * leadSq)
    if gunValid and gun.acfMuzzleVel then
        local mv = gun:acfMuzzleVel() or 0
        if mv > 0 then
            local mvGu = mv * 39.3701
            local dist = (gun:getMassCenterW() or gun:getPos()):getDistance(basePos)
            local estTta = ballisticTime(dist) or 0
            if estTta > 0 then
                local maxLead = mvGu * estTta
                local offset = aimBasePos - basePos
                local offLen = offset:getLength()
                if offLen > maxLead then
                    aimBasePos = basePos + offset * (maxLead / offLen)
                end
            end
        end
    end
    local targetPredPos = aimBasePos
    local aimPos = basePos
    local tta    = 0

    local activeControl =
        Unlocked and not manual and
        gunValid and
        baseValid

    local loadActive = loadEnabled and Unlocked and not manual and not LastReady

    if loadActive then
        local loadPos = getLoadAimPos(gun, base, targetPredPos, loadAng)
        if loadPos then
            aimPos = loadPos
        end
        tta = 0
    elseif activeControl then
        aimPos, tta = getBallisticAimPos(gun, base, targetPredPos, tvel, tacc)
    else
        aimPos = basePos
        tta    = 0
    end

    Outputs.TurretActive:update((Unlocked or loadActive) and 1 or 0)
    Outputs.HAimPos:update(aimPos)
    Outputs.VAimPos:update(aimPos)
    Outputs.TargetPredPos:update(targetPredPos)
    Outputs.TTA:update(tta)
    Outputs.Elevation:update(0)
end

updateInputs("Lock:NORMAL Active:NORMAL M2:NORMAL Gun:ENTITY Base:ENTITY HitPos:VECTOR TargetPos:VECTOR TargetVel:VECTOR")
updateOutputs("TurretActive:NORMAL HAimPos:VECTOR VAimPos:VECTOR TargetPredPos:VECTOR TTA:NORMAL Elevation:NORMAL")

Inputs.Lock:addTrigger(function(v)
    if v == 0 then return end
    Unlocked = not Unlocked
end)

Inputs.Active:addTrigger(function(v)
    Unlocked = false
end)

hook.add("think", "SF_MGC", main)
